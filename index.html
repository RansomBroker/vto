<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hand Tracking with MediaPipe and Three.js</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
    }
    .canvasContainer {
      position: relative;
      width: 640px;
      height: 480px;
    }
    video {
      display: none;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #outputCanvas {
      z-index: 1;
    }
    #threeCanvas {
      z-index: 2;
    }
  </style>
</head>
<body>
  <video id="videoInput" playsinline></video>
  <div class="canvasContainer">
    <canvas id="outputCanvas" width="640" height="480"></canvas>
    <canvas id="threeCanvas" width="640" height="480"></canvas>
  </div>

  <script>
    const videoElement = document.getElementById('videoInput');
    const outputCanvas = document.getElementById('outputCanvas');
    const outputCtx = outputCanvas.getContext('2d');
    const threeCanvas = document.getElementById('threeCanvas');

    // Function to start the video stream
    async function startVideo() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoElement.srcObject = stream;
        await videoElement.play();
      } catch (err) {
        console.error('Error accessing the camera: ', err);
      }
    }

    startVideo();

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // Three.js setup
    let renderer, scene, camera, bracelet;
    const wristCubes = [];

    try {
      renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true });
      renderer.setSize(threeCanvas.width, threeCanvas.height);
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(
        -threeCanvas.width / 2, threeCanvas.width / 2,
        threeCanvas.height / 2, -threeCanvas.height / 2,
        -1000, 1000
      );
      camera.position.z = 1;
    } catch (e) {
      console.error('WebGL not supported, falling back on experimental-webgl', e);
      renderer = null;
      alert('WebGL not supported, please update your browser or GPU drivers.');
    }

    // Load the bracelet model
    const loader = new THREE.GLTFLoader();
    loader.load('casio.glb', (gltf) => {
      bracelet = gltf.scene;
      scene.add(bracelet);
      console.log('Bracelet model loaded successfully');
    }, undefined, (error) => {
      console.error('An error occurred loading the bracelet model: ', error);
    });

    const cubes = [];

    // Function to create a cube
    function createCube(x, y, z, color = 0x00ff00) {
      const geometry = new THREE.BoxGeometry(10, 10, 10);
      const material = new THREE.MeshBasicMaterial({ color });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      return cube;
    }

    // Function to calculate the distance between two landmarks
    function calculateDistance(landmark1, landmark2) {
      const dx = landmark1.x - landmark2.x;
      const dy = landmark1.y - landmark2.y;
      const dz = landmark1.z - landmark2.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }


    // Reference pose angles
    let referenceAngles = { x: 0, y: 0, z: 0 };

    // Function to calculate reference angles based on the given reference pose image
    function calculateReferenceAngles(landmarks) {
      const wristIndex = 0; // Wrist landmark index
      const indexBaseIndex = 5; // Index finger base landmark index
      const pinkyBaseIndex = 17; // Pinky finger base landmark index

      const dx = landmarks[pinkyBaseIndex].x - landmarks[indexBaseIndex].x;
      const dy = landmarks[pinkyBaseIndex].y - landmarks[indexBaseIndex].y;
      const dz = landmarks[pinkyBaseIndex].z - landmarks[indexBaseIndex].z;

      referenceAngles.z = Math.atan2(dy, dx);
      referenceAngles.x = Math.atan2(dy, dz);
      referenceAngles.y = Math.atan2(dx, dz);
    }

    // Initialize with reference angles based on the initial hand pose
    async function initializeReferenceAngles() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      videoElement.srcObject = stream;
      await videoElement.play();

      hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          calculateReferenceAngles(results.multiHandLandmarks[0]);
          hands.onResults(onResults); // Switch back to the main results handler
        }
      });

      const cameraStream = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480
      });

      cameraStream.start();
    }

    // Function to handle results from MediaPipe Hands
    function onResults(results) {
      // Draw video feed and landmarks on the output canvas
      outputCtx.save();
      outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
      outputCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);

      if (results.multiHandLandmarks) {
        results.multiHandLandmarks.forEach((landmarks, handIndex) => {
          if (!cubes[handIndex]) {
            cubes[handIndex] = [];
          }
          landmarks.forEach((landmark, index) => {
            const x = landmark.x * outputCanvas.width - outputCanvas.width / 2;
            const y = -landmark.y * outputCanvas.height + outputCanvas.height / 2;
            const z = -landmark.z * 100; // Scale z for better visualization

            if (!cubes[handIndex][index]) {
              cubes[handIndex][index] = createCube(x, y, z);
            } else {
              const cube = cubes[handIndex][index];
              cube.position.set(x, y, z);
            }
          });

          // Calculate wrist size using landmarks 0, 1, and 5
          if (landmarks.length > 5) {
            const wristSize = calculateDistance(landmarks[0], landmarks[1]) +
                              calculateDistance(landmarks[1], landmarks[5]) +
                              calculateDistance(landmarks[5], landmarks[0]);
            //console.log(`Wrist size for hand ${handIndex}: ${wristSize}`);

            // Position and scale the bracelet
            const wristX = landmarks[0].x * outputCanvas.width - outputCanvas.width / 2;
            const wristY = -landmarks[0].y * outputCanvas.height + outputCanvas.height / 2;
            const wristZ = -landmarks[0].z * 100;

            //bracelet.position.set(wristX * 320, wristY * 240, wristZ);
            bracelet.scale.set(wristSize * 20 , wristSize * 20, wristSize* 20);
          }

          // Position and rotate the bracelet model on the wrist landmark
          const wristIndex = 0; // Wrist landmark index
          const indexBaseIndex = 5; // Index finger base landmark index
          const pinkyBaseIndex = 17; // Pinky finger base landmark index

          // Calculate the rotation angles
          const dx = landmarks[pinkyBaseIndex].x - landmarks[indexBaseIndex].x;
          const dy = landmarks[pinkyBaseIndex].y - landmarks[indexBaseIndex].y;
          const dz = landmarks[pinkyBaseIndex].z - landmarks[indexBaseIndex].z;

          const angleZ = Math.atan2(dy, dx) - referenceAngles.z;
          const angleX = Math.atan2(dy, dz) - referenceAngles.x;
          const angleY = Math.atan2(dx, dz) - referenceAngles.y;

          // Apply the rotations to the bracelet model
          bracelet.rotation.set(angleX, 0, 0);

          // Log the rotation angles
          console.log(`Rotation angles: x=${angleX.toFixed(2)}, y=${angleY.toFixed(2)}, z=${angleZ.toFixed(2)}`);
        });
        // Render the scene with the updated cube positions
        renderer.render(scene, camera);
      }

      outputCtx.restore();
    }

    // Start the camera stream and initialize the reference angles
    initializeReferenceAngles();
  </script>
</body>
</html>
