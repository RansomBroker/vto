<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hand Tracking with MediaPipe and Three.js</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
    }
    .canvasContainer {
      position: relative;
      width: 640px;
      height: 480px;
    }
    video {
      display: none;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #outputCanvas {
      z-index: 1;
    }
    #threeCanvas {
      z-index: 2;
    }
  </style>
</head>
<body>
  <video id="videoInput" playsinline></video>
  <div class="canvasContainer">
    <canvas id="outputCanvas" width="640" height="480"></canvas>
    <canvas id="threeCanvas" width="640" height="480"></canvas>
  </div>

  <script>
    const videoElement = document.getElementById('videoInput');
    const outputCanvas = document.getElementById('outputCanvas');
    const outputCtx = outputCanvas.getContext('2d');
    const threeCanvas = document.getElementById('threeCanvas');

    // Function to start the video stream
    async function startVideo() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoElement.srcObject = stream;
        await videoElement.play();
      } catch (err) {
        console.error('Error accessing the camera: ', err);
      }
    }

    startVideo();

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // Three.js setup
    let renderer, scene, camera, bracelet;
    try {
      renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true });
      renderer.setSize(threeCanvas.width, threeCanvas.height);
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(
        -threeCanvas.width / 2, threeCanvas.width / 2,
        threeCanvas.height / 2, -threeCanvas.height / 2,
        -1000, 1000
      );
      camera.position.z = 1;

      // Add ambient light to the scene
      const ambientLight = new THREE.AmbientLight(0x404040, 3); // soft white light
      scene.add(ambientLight);

      // Add directional light to the scene
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);

    } catch (e) {
      console.error('WebGL not supported, falling back on experimental-webgl', e);
      renderer = null;
      alert('WebGL not supported, please update your browser or GPU drivers.');
    }

    const loader = new THREE.GLTFLoader();
    loader.load('gelang_2.glb', (gltf) => {
      bracelet = gltf.scene;
      scene.add(bracelet);
      console.log('Bracelet model loaded successfully');
    }, undefined, (error) => {
      console.error('An error occurred loading the bracelet model: ', error);
    });

    // Function to calculate the distance between two landmarks
    function calculateDistance(landmark1, landmark2) {
      const dx = landmark1.x - landmark2.x;
      const dy = landmark1.y - landmark2.y;
      const dz = landmark1.z - landmark2.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    const axesHelper = new THREE.AxesHelper(100);
    scene.add(axesHelper);

    // create landmark
    const cubes = [];

    // Function to create a cube
    function createCube(x, y, z) {
      const geometry = new THREE.BoxGeometry(10, 10, 10);
      
      // Function to generate a random color
      function getRandomColor() {
        return Math.floor(Math.random() * 16777215);
      }

      // Create an array of materials, one for each face
      const materials = [
        new THREE.MeshBasicMaterial({ color: getRandomColor() }), // Right face
        new THREE.MeshBasicMaterial({ color: getRandomColor() }), // Left face
        new THREE.MeshBasicMaterial({ color: getRandomColor() }), // Top face
        new THREE.MeshBasicMaterial({ color: getRandomColor() }), // Bottom face
        new THREE.MeshBasicMaterial({ color: getRandomColor() }), // Front face
        new THREE.MeshBasicMaterial({ color: getRandomColor() })  // Back face
      ];

      const cube = new THREE.Mesh(geometry, materials);
      cube.position.set(x, y, z);
      scene.add(cube);
      return cube;
    }

    // Function to handle results from MediaPipe Hands
    function onResults(results) {
      // Draw video feed and landmarks on the output canvas
      outputCtx.save();
      outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
      outputCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);

      if (results.multiHandLandmarks) {
        results.multiHandLandmarks.forEach((landmarks, handIndex) => {
          if (!cubes[handIndex]) {
            cubes[handIndex] = [];
          }
          landmarks.forEach((landmark, index) => {
            const x = landmark.x * outputCanvas.width - outputCanvas.width / 2;
            const y = -landmark.y * outputCanvas.height + outputCanvas.height / 2;
            const z = -landmark.z * 100; // Scale z for better visualization

            if (!cubes[handIndex][index]) {
              cubes[handIndex][index] = createCube(x, y, z);
            } else {
              const cube = cubes[handIndex][index];
              cube.position.set(x, y, z);
            }
          });

          if (landmarks.length > 5) {
            const wristSize = calculateDistance(landmarks[0], landmarks[1]) +
                              calculateDistance(landmarks[1], landmarks[5]) +
                              calculateDistance(landmarks[5], landmarks[0]);

            // Position and scale the bracelet
            const wristX = landmarks[0].x * outputCanvas.width - outputCanvas.width / 2;
            const wristY = -landmarks[0].y * outputCanvas.height + outputCanvas.height / 2;
            const wristZ = -landmarks[0].z * 100;

            bracelet.position.set(wristX, wristY, wristZ);
            bracelet.scale.set(wristSize * 50, wristSize * 50, wristSize * 50);

            // Calculate rotation to face the user
            const wrist = landmarks[0];
            const indexFingerBase = landmarks[5];
            const middleFingerBase = landmarks[9];

            const handDirection = new THREE.Vector3(
              indexFingerBase.x - wrist.x,
              indexFingerBase.y - wrist.y,
              indexFingerBase.z - wrist.z
            ).normalize();

            const upDirection = new THREE.Vector3(
              middleFingerBase.x - wrist.x,
              middleFingerBase.y - wrist.y,
              middleFingerBase.z - wrist.z
            ).normalize();

            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), handDirection);

            const handRotation = new THREE.Euler().setFromQuaternion(quaternion);
            bracelet.rotation.copy(handRotation);

            // Adjust the bracelet orientation to ensure it faces the correct direction
            bracelet.rotation.z += Math.PI / 2;
          }
        });

        // Render the scene with the updated axes helper position and rotation
        renderer.render(scene, camera);
      }

      outputCtx.restore();
    }

    const cameraStream = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });

    cameraStream.start();
  </script>
</body>
</html>
